二分查找
public static int quickSort(int[]arr, int n, int target) {
        int l = 0;
        int r = n - 1;
        //区间[l,r]l里查找target
        while (l <= r) {
            int mid = l + (r - l)/2;
            if (arr[mid] == mid) {
                return mid;
            } else if (target > arr[mid]) {
                // target 在【mid + 1, r】
                l = mid + 1;
            } else {
                // target 在【l, mid -1】
                r = mid - 1;
            }
        }
        return -1;
    }
    复制为 r = n 时，while循环变成 l < r;
    那么 当l = r,区间[l,r)则是无效的[42,42)无效，[42,43)有效
       while (l < r) {
                int mid = l + (r - l)/2;
                if (arr[mid] == mid) {
                    return mid;
                } else if (target > arr[mid]) {
                    // target 在【mid + 1, r)
                    l = mid + 1;
                } else {//target < arr[mid]
                    // target 不在【l, mid )中
                    r = mid;
                }
          }